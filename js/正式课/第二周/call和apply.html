<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
//    非严格模式：
//    call apply bind ： 改变this关键字；
//    是一个方法，存在于Function这个内置类的原型上；
//    所有的函数可以调用Function这个类上的方法；
//    call方法作用：如果call没有传参数，那么方法中的this还是window
//    如果call传参数为null和undefined，那么方法中的this指向window
//    如果call传参数，那么第一个参数是谁，方法中的this就是谁；如果fn1中也需要参数，那么把参数放进call后面的括号中，用逗号一次隔开；
//    call原理：
//    首先通过原型链找到Function这个类原型上的call方法，然后让call方法执行；
//    call方法执行的时候，让call方法传进去第一个参数变成call方法中this的this；然后让call方法中的this执行；
//    严格模式："use strict"；
//    如果call没有传参数，那么方法中的this指向undefined
//    如果方法中传的是null，this指向null，传undefined，this就是指向undefined
//    function fn1(num1) {
//        console.log(num1);//0
//        console.log(1);
//        console.log(this);//fn2
//    }
//    function fn2() {
//        console.log(2);//没有执行
//    }
//
//    fn1.call(fn2,0)
//
//    apply：
//    apply和call方法的区别：传参数不一样,当不止有一个参数，把第二个及以后的参数放进一个数组中，一块传递进去；
//    bind：不兼容ie678；预处理this关键字方法没有立即执行，执行bind会有一个返回值，返回值是我们想要的结果，它的传参与call类似；
//
//    function fn1(num1) {
//        console.log(num1);//0
//        console.log(1);
//        console.log(this);//fn2
//    }
//    function fn2() {
//        console.log(2);//没有执行
//    }
//
//    fn1.apply(fn2,[0]);
//    var f=fn1.bind(fn2,13);
//    f();
//    第二个call方法执行，里面的this就是fn1.call，让fn1.call里面的this变成fn2；
//    让fn1.call执行，改变里面的this，让里面的this（fn2）执行，
//    function fn1(num1) {
//        console.log(num1);//0
//        console.log(1);
//        console.log(this);//fn2
//    }
//    function fn2() {
//        console.log(2);//没有执行
//    }
//
//    fn1.call.call(fn2);
//

</script>
</body>
</html>