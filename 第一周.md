## 预解释
===
在全局下定义的变量，相当于给 window增加了一个属性名和属性值
 
 
	 console.log(num); //undefined
	 var num = 1 ;
	 console.log(num); //1
	 
	 console.log(num);  //not a defined
	 num = 1;
	 console.log(num); //1
	
形成全局作用域，然后进行预解释；

预解释：在代码执行之前会把带var的和function的变量进行提前的声明

变量提声：在代码执行之前，把被var 和 function 的变量进行声明

当js加载之前首先浏览器会形成一个全局作用域，提供代码执行环境的


全局作用域和私有作用域全是栈内存；

基本数据类型存储到栈内存，引用数据类型都是存储到堆内存；

	console.log(fn) //整个函数体
	function fn() {
		console.log(1);
	}

var 和 function ：

共同点： 都要进行变量提升

不同点：var只声明不定义；function不仅声明还进行定义

**在全局作用域下var与不带var的关系：**

区别：带var的了一进行预解释，所以在赋值的前面执行不会报错；不带var的事不能进行预解释的，在前面执行会报错

关系：num＝12；相当于给window增加了属性名，属性值是赋值
var num＝12；首先它相当于给全局作用域增加一个全局变量，也相当于给window增加了属性名。



预解释的特殊情况：

	in ：判断某个属性是否在某个对象中存在；返回一个布尔值
	例： 	   var obj={sep:9};
			console.log("sep" in obj) //true
			console.log(sep in“ ”obj)  //sep is not defined
	条件语句中的预解释：
	在全局下定义的变量，在预解释时，给window添加一个属性名；
	if（“a” in window）{
		var a=0;
		console.log(a);
	}
	
预解释的变态机制：

* 在条件语句中，不管条件成立不成立，都要进行预解释，function在最新版本浏览器中，只声明不定义，老版本浏览器不仅声明还定义
		
		console.log(b);  //undefined
		console.log(fn); //undefined
		if(1==2){
			var b="hello";
			function fn(){
			}
		}
* 等号右边的不进行预解释
		
		console.log(sum);//sum is not defined
    	console.log(fn); //undefined
    	var fn = function sum() {
        console.log(1)
    	}
*  return 出去的内容是不进行预解释的，return下面的内容时进行预解释的
*  匿名函数不需要进行预解释
*  如果变量名字重复，变量只声明一次，当代码执行时，会重新定义 

##  栈内存  堆内存
===
在页面加载html时，首先会形成一个全局的作用域（执行环境），然后进行预解释，预解释完成之后，代码从上到下开始执行；

基本数据类型值存储到栈内存中；

引用数据类型存储到堆内存中；

全局作用域和私有作用域都是栈内存；

如何区分私有变量和全局变量

	1.在全局作用域下声明（预解释的时候）的变量是全局变量
	2.在“私有作用域中声明的变量”和“函数的形参”都是私有的变量


**私有作用域**：

		1.当函数执行的时候会形成私有作用域；
		2.形参赋值
		3.进行预解释
		4.代码从上到下执行；
		
堆内存：存储大量数据或信息

查找  上级作用域：`首先要看私有变量，如果这个私有作用域不存在，往上级作用域区查找，如果上级作用域也不存在这个变量，会继续往上一级查找，直到window，如果window也没有，就报错=>作用域链
`

**上级作用域 ：与函数在哪执行的没有任何关系，只需看函数在哪定义的
**

`形参是私有变量`

`怎么判断是私有变量：1，看当前变量是否是形参，2，看当前变量有没有被var过
`
## 内存释放
===
**堆内存清除占用：**

谷歌：谷歌浏览器每隔一段时间会对当前的堆内存进行检查，检查当前这个地址有没有被占用，发现这个地址已经不被占用，就会自动回收

ie和火狐：每当对当前地址引用一次，浏览器默认进行计数，在当前次数上加1.如果不再引用，浏览器会减1，直到当前次数为0，浏览器会对这个堆内存进行回收

手动清空堆内存  null
	
		obj ＝ null；
		
**栈内存销毁**

当你打开页面时会提供一个供代码运行的环境，全局作用域是不销毁的作用域，只有当关闭页面，那么作用域才会销毁；

**私有作用域：**

函数执行：先形成私有作用域－－>形参赋值－－>预解释－－>代码从上到下执行

一般情况下函数执行完成以后会自动销毁；如果函数再次执行，会形成一个新的私有的作用域，并且俩个私有作用域相互之间不会干扰；

特殊情况：
		
不销毁的作用域：函数执行return出一个引用数据类型值，并且被外界变量接收，那么当前这个私有的作用域不会销毁

		 function  fn(){
		 	var total = 10;
		  	return function (){
		  	console.log(total);
		  	}
		 }
		 var b=fn();
		 b();

自执行函数也不销毁作用域

不立即销毁作用域

		function  fn(){
		 	var total = 10;
		  	return function (){
		  	console.log(total);
		  	}
		 }；
		fn()();
闭包：

函数执行时形成一个私有的作用域保护里面的私有变量不受外界干扰

1.保护里面变量不受外界干扰

2.保护值

## this
===

	在函数中，代表当前函数执行的主体，或者是谁让这个函数执行的。
	1。给元素的某个事件（点击，滑过，滑出。。。）绑定方法，那么方法中的this，指向当前被绑定的元素。
	2.要判断方法中的this，需要看当前函数的前面是否有“.”，有的话，点前面是谁，this就是谁，如果没有点，那么this就是window；
	3.自执行函数中的this永远指向window
	4.全局下的this指向window；
	5.定时器中的this永远指向window
	6.类中的this指向当前的实例
	
## 单例模式：
把描述同一件事物不同属性放在一个命名空间下，起到了分组的作用，对象的名字我们称为命名空间

## 工厂模式
批量生产，实现函数的封装（低耦合，高内聚）

## 面向对象
===
 对象 ：在js中万物皆对象；
 
 **面向对象：**类的继承、封装、多态；
 
 所有后台语言都是面向对象开发的
 
 **类：**是对象的一个具体的划分
 
 **实例**：类中某一个具体的事物，所有的实例都是对象数据类型 
 
 内置类的首字母要大写
 
 **内置类**:Array、Number String Boolean Null Undefined Object Function Date Regexp,Math不是一个类  是一个方法；
 
 **类的继承**：子类继承父类的属性和方法
 
 **类的封装：**吧相同功能的代码放到函数中，当想实现这个功能的时候，直接执行这个函数“函数的封装” “高内聚低耦合”
 
**类的多态：**  类的多种形态  ，重载和重写；js没有重载；

**重写**：子类重写父类的方法；
 
 **instanceof**：判断某个实例是否属于某个类的，检测基本数据类型只能检测通过实例创建的变量，字面量创建的不能检测出来
 		
 	ary instanceof Array
	

**实例创建**：在类的前面加一个new，就是创建一个实例的意思；

object  是基类  也是最顶层的类，所有的实例最终都会指向object。

## 构造函数＝＝类（new＋函数）
===
判断当前函数是不是一个类，看当前函数有没有被new过

new ＋ 类：就是一个实例；

类中的this指向当前的实例

构造函数和工厂模式的区别：
	
	相同点：1.函数执行 形成私有作用域  形参赋值 预解释 代码从上到下执行
	不同点：1.类中不需要创建空对象   不需要return出这个对象，浏览器在执行时，会默认创建一个空对象，最后把它返回；2.类中的this指向当前实例；
	
所有的类都是函数数据类型的，所有的实例都是对象数据类型的

函数既可以是一个普通的函数也可以作为类

类的开头字母一般时大写；

类分为内置类和自定义类；

writejs是每个实例的私有属性，所以不相等

	p1.writejs === p2.writejs   //结果返回是false
	
实例的特点：
	
	1.如果类不需要传参数，后面括号可以省略，类也是执行的
	2.类中实例属性的方法中的this，指向当前实例，一定要看怎么执行的
	3.这个类中的私有变量和当前的实例没有任何的关系
	4.在类中如果reutrn出一个基本数据类型的值，那么这个new下的这个类返回的还是那个实例，如果return出一个引用数据类型值，那么实例会被覆盖掉，new＋类的返回值就是return的对象；
	
## 原型

prototype:属性值是一个对象数据类型的值；

构造函数实现了实例和实例之间属性和方法都不相同，都是私有属性。 实例识别；

函数也是一个实例

判断是否私有属性

	 hasOwnproperty:检测当前属性是否是私有属性，返回布尔值；如果是私有的返回true，如果不是返回false；写法为  实例. hasOwnproperty("方法名")
	 
	 in:私有或者公有的都可以监测
	 
1.每一个函数数据类型（普通函数、类（内置类、自定类））都天生自带一个prototype属性；

2.prototype属性天生自带一个constructor属性，属性值是当前原型所对应的那个类；

3.每一个对象数据类型都天生自带一个__proto__属性，它的属性值，指向当前实例所对应的那个类的原型。


获取对象属性名对应的属性值  对象.对象名；

对象.属性名：首先查看是否是自己的私有属性，如果不是，实例会通过__proto__这个属性，去当前实例的对应的类的原型上去继续查找，如果类的原型上不存在，那么会继续通过__proto__往上级查找，这种查找的机制叫“原型链模式”

在ie10以下，有__proto__这个属性，ie给禁用，不兼容

下面把fn原型的属性值重新覆盖，失去了constructor，所以手动添上；

	fn.prototype = {
		constructor:fn,
		getx:function(){
		
		}
	}
 
 判断是否是一个公有属性：
 
 	function hasPublicProperty(obj,prototype){
 		if(obj.hasOwnproperty(prototype)){
 			return false;
 		}else{
 			return true;
 		}
 		
 	}
 	